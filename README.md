![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA.PNG?raw=true)

## Что произошло? 
Джо не сообразил, что летать
должны не все субклассы Duck.
Новое поведение, добавленное
в суперкласс Duck, оказалось неподходящим для некоторых субклассов. И теперь в программе
начали летать неодушевленные
объекты
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA1.PNG?raw=true)

![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA3.PNG?raw=true)

Чем различаются эти два заказа? Да ничем! Они абсолютно одинаковые, если не считать того, что Элис произнесла вдвое больше слов и едва не вывела из себя старого
ворчливого официанта.
Что есть у Фло, чего нет у Элис? Единая номенклатура с официантом. Она не только упрощает общение, но и помогает официанту запомнить заказ, потому что все
паттерны блюд хранятся у него в голове.
Паттерны проектирования формируют единую номенклатуру для разработчиков.
Когда вы овладеете этой номенклатурой, вам будет проще общаться с другими разработчиками — а у тех, кто паттернов не знает, появится лишний стимул для их изучения. Кроме того, вы начнете воспринимать архитектуру на более высоком уровне
паттернов, а не на уровне объектов.

![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA4.PNG?raw=true)

Разработчик:Хм, но разве дело не сводится к ОО-проектированию?
Если я следую принципам инкапсуляции, знаю об абстракции, наследовании и полиморфизме, то зачем мне думать о паттернах проектирования? Для чего тогда были нужны те курсы ОО-проектирования?
Я думаю, паттерны проектирования полезны только тем, кто не разбирается в ОО-проектировании.
Гуру: О, это одно из известных заблуждений объектно-ориентированной разработки: будто знание основ ООП автоматически позволит
вам строить гибкие, удобные в сопровождении и пригодные к повторному использованию системы.
Разработчик: Нет?
Гуру: Hет. Более того, принципы построения ОО-систем, обладающих такими свойствами, далеко не всегда очевидны.
Разработчик: Кажется, я начинаю понимать. И на основе этих неочевидных принципов построения объектно-ориентированных систем
были сформулированы...
Гуру: ...да, были сформулированы паттерны проектирования.

## Ответы к упражнениям
Character — абстрактный суперкласс для всех классов персонажей (King, Queen, Knight и Troll), а интерфейс WeaponBehavior
реализуется всеми классами поведения оружия. Все классы персонажей и оружия являются конкретными.
Чтобы сменить оружие, персонаж вызывает метод setWeapon(),
определяемый в суперкласс Character. Во время сражения для
текущего оружия персонажа вызывается метод useWeapon().
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5.PNG?raw=true)

Издатели + Подписчики = Паттерн Наблюдатель

Если вы понимаете, как работает газетная подписка, вы в значительной мере понимаете и паттерн Наблюдатель — только
в данном случае издатель называется СУБЪЕКТОМ, а подписчики — НАБЛЮДАТЕЛЯМИ.
Присмотримся повнимательнее.
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA6.PNG?raw=true)




# Уникальные объекты
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-1.PNG?raw=true)

**Паттерн Одиночка направлен на создание уникальных объектов, существующих только в одном экземпляре.** Из всех паттернов Одиночка имеет самую простую диаграмму классов; собственно, вся диаграмма состоит из одного-единственного класса! Однако не стоит расслабляться; несмотря на всю его простоту с точки зрения архитектуры классов, в его реализации кроется немало ловушек. Так что пристегните ремни!

**Программист:** И в чем польза такого паттерна?

**Гуру:** Существует много объектов, которые нужны нам только в одном экземпляре: пулы программных
потоков, кэши, диалоговые окна, объекты ведения журнала, объекты драйверов устройств... Более того,
для многих типов таких объектов попытка создания более одного экземпляра приведет к всевозможным проблемам — некорректному поведению программы, лишним затратам ресурсов или нелогичным
результатам.

**Программист:** Хорошо, некоторые классы действительно должны создаваться только в одном экземпляре.
Но писать об этом целую главу? Разве нельзя, например, воспользоваться глобальной переменной? А в Java
можно было добиться желаемого с помощью статической переменной.

**Гуру:** Паттерн Одиночка во многих отношениях представляет собой схему, которая гарантирует, что для заданного класса может быть создан один и только один объект. Если кто-нибудь придумает более удачное решение, мир о нем услышит; а пока паттерн Одиночка, как и все паттерны, представляет собой проверенный
временем механизм создания единственного объекта. Кроме того, Одиночка, как и глобальная переменная,
предоставляет глобальную точку доступа к данным, но без ее недостатков.

**Программист:** Каких недостатков?

**Гуру:** Простейший пример: если объект присваивается глобальной переменной, он может быть создан в начале работы приложения. Верно? А если этот объект расходует много ресурсов, но никогда не будет использоваться приложением? Как вы увидите, паттерн Одиночка позволяет создавать объекты в тот момент, когда
в них появится необходимость.

**Программист:** И все равно не вижу ничего особенно сложного.

**Гуру:** Для того, кто хорошо разбирается в статических переменных и методах, а также модификаторах доступа, — ничего сложного нет. Но как бы то ни было, интересно посмотреть, как работает паттерн Одиночка,
и при всей простоте его довольно непросто реализовать. Как бы вы предотвратили создание повторных
экземпляров? Задача отнюдь не тривиальная, не правда ли?

## Вопросы и ответы
#### Маленькое упражнение в стиле сократовских диалогов
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-2.PNG?raw=true)
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-3.PNG?raw=true)
### Классическая реализация паттерна Одиночка
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-4.PNG?raw=true)

# Паттерны для всех
## Интервью недели: Признания Одиночки
**HeadFirst:** Сегодня вниманию слушателей предлагается интервью с объектом Одиночкой. Может,
немного расскажете о себе?

**Одиночка:** Я единственный и неповторимый!

**HeadFirst:** Неужели?

**Одиночка:** Да. Я создан на основе паттерна Одиночка, а это гарантирует, что в любой момент времени
существует только один экземпляр моего класса.

**HeadFirst:** Разве это не расточительно? Кто-то тратит время на создание класса, а потом по этому описанию создается всего один объект?

**Одиночка:** Вовсе нет! Во многих случаях существование одиночных объектов оправдано. Предположим, в объекте хранятся настройки реестра. Если кто-то создаст несколько экземпляров такого объекта, это может привести к хаосу. Одиночные объекты гарантируют, что все компоненты вашего приложения будут использовать один и тот же глобальный ресурс.

**HeadFirst:** Продолжайте...

**Одиночка:** О, я отлично подхожу для подобных задач. Одиночество имеет свои преимущества. Меня
часто используют для управления пулами ресурсов — скажем, подключений или программных потоков.

**HeadFirst:** И все-таки — быть всегда одним? Вам не скучно?

**Одиночка:** Так как мне никто не помогает, скучать некогда. Но разработчикам не помешало бы получше изучить меня — во многих программах возникают ошибки, когда в системе создаются дополнительные экземпляры объектов, о которых их создатель и не подозревает.

**HeadFirst:** Но как можно быть уверенным в том, что вы существуете в одном экземпляре? Разве любой
желающий не сможет создать новый экземпляр оператором new?

**Одиночка:** Нет! Я абсолютно уникален.

**HeadFirst:** Разработчики торжественно клянутся не создавать более одного экземпляра?

**Одиночка:** Нет, конечно. Возможно, это дело личное, но... у меня нет открытого конструктора.

**HeadFirst:** НЕТ ОТКРЫТОГО КОНСТРУКТОРА?! Ох, извините... неужели нет?

**Одиночка:** Вот именно. Мой конструктор объявлен приватным..

**HeadFirst:** И как работает эта схема? Как ВООБЩЕ можно создать экземпляр?

**Одиночка:** Чтобы получить объект, вы не создаете его экземпляр, а запрашиваете его. Мой класс содержит статический метод с именем getInstance(). Вызовите его, и вы получите экземпляр, готовый
к работе. Может оказаться, что к этому моменту я уже существую и обслуживаю другие объекты.

**HeadFirst:** Похоже, в этой схеме многое остается скрытым от посторонних глаз! Спасибо, что приняли наше приглашение. Надеемся, наша беседа скоро продолжится!

## Шоколадная фабрика
Всем известно, что на всех современных шоколадных фабриках используются
нагреватели с компьютерным управлением. Смесь шоколада и молока в таком
нагревателе доводится до кипения и передается на следующий этап изготовления шоколадных батончиков. Ниже приведен код класса, управляющего ChocO-Holic — мощным высокопроизводительным нагревателем для шоколада. Просмотрите код; вы заметите, что автор постарался сделать все возможное, чтобы
избежать некоторых неприятностей — скажем, слива холодной смеси, переполнения или нагревания пустой емкости!
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-5.PNG?raw=true)
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-6.PNG?raw=true)

### Возьми в руку карандаш
**Сможете ли вы усовершенствовать класс ChocolateBoiler,
преобразовав его в синглетную форму (то есть с единственным экземпляром)?**
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-7.PNG?raw=true)

## Определение паттерна Одиночка
**Итак, вы познакомились с классической реализацией паттерна Одиночка. Сейчас можно
устроиться поудобнее, съесть шоколадку и перейти к рассмотрению некоторых нюансов
паттерна Одиночка.**

**Начнем с формального определения паттерна:**

**Паттерн Одиночка** гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку
доступа к этому экземпляру.

**Пока ничего особенного. Но давайте присмотримся повнимательнее:**

* Что здесь по сути происходит? Мы берем существующий класс и разрешаем ему создать только один экземпляр. Кроме того, мы запрещаем любым другим классам произвольно создавать новые экземпляры этого класса. Чтобы получить экземпляр, необходимо обратиться с запросом к самому классу.

* Кроме того, паттерн предоставляет глобальную точку доступа к экземпляру: обратившись с запросом к классу в любой точке программы, вы получите ссылку на
единственный экземпляр. Как было показано выше, возможно отложенное создание
экземпляра, что особенно важно для объектов, создание которых сопряжено с большими затратами ресурсов.

**Обратимся к диаграмме классов:**
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-8.PNG?raw=true)

## Кажется, у нас проблемы...

**Похоже, программа управления нагревателем нас подвела; хотя мы усовершенствовали код и перешли на классическую реализацию паттерна Одиночка, метод fill() класса ChocolateBoiler почему-то начал заполнять емкость, которая уже была заполнена! 500 галлонов молока (и шоколада) пролилось на пол. Что произошло?!**
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-9.PNG?raw=true)

**Могло ли введение программных потоков
привести к катастрофе? Ведь после того, как
переменной uniqueInstance будет присвоен
единственный экземпляр ChocolateBoiler, все
вызовы getInstance() должны возвращать один
и тот же экземпляр? Разве нет?**
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-10.PNG?raw=true)

## Решение проблемы многопоточного доступа

**Наши многопоточные проблемы решаются почти тривиально: метод getInstance()
объявляется синхронизированным:**
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-11.PNG?raw=true)

В точку! На самом деле ситуация еще серьезнее: синхронизация актуальна только при первом вызове этого метода.
Иначе говоря, после того, как переменной uniqueInstance
будет присвоен экземпляр синглетного класса, необходимость в дальнейшей синхронизации этого метода отпадает.
После первого выполнения синхронизация только приводит к лишним затратам ресурсов!

## Можно ли усовершенствовать многопоточную реализацию?

Безусловно, в большинстве Java-приложений мы должны позаботиться о том, чтобы паттерн работал в многопоточном коде. Но синхронизация метода getInstance() приводит к значительным затратам ресурсов. Что же делать? Есть несколько вариантов.

## 1. Ничего не делать, если производительность getInstance() не критична для вашего приложения 

Да, вы не ошиблись: если вызов getInstance() не приводит к заметному ухудшению быстродействия, не обращайте внимания. Синхронизация getInstance() — простое и эффективное решение. Только помните, что синхронизация метода может замедлить его выполнение в сто и более раз. Если метод getInstance() применяется в интенсивно используемой части приложения, возможно, вам стоит пересмотреть свое решение.

## 2. Создавайте экземпляр заранее

Если приложение всегда создает и использует экземпляр синглетного класса или затраты за создание не столь существенны, экземпляр можно создать заранее:
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-12.PNG?raw=true)

При таком подходе мы доверяем JVM создание уникального экземпляра Singleton при загрузке класса. JVM гарантирует, что экземпляр будет создан до того, как какой-либо поток сможет обратиться к статической переменной uniqueInstance. 

## 3. Воспользуйтесь «условной блокировкой», чтобы свести к минимуму использование синхронизации в getInstance()

Сначала проверьте, создается ли новый экземпляр, и если нет — ТОГДА синхронизируйте фрагмент кода. В этом случае синхронизация будет выполняться только при первом вызове (что нам, собственно, и требовалось).
Давайте проверим код:
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-13.PNG?raw=true)

Если производительность выполнения getInstance() критична, то этот способ
реализации кардинально ускорит выполнение метода.
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-14.PNG?raw=true)

### Тем временем на шоколадной фабрике...

Пока мы разбирались с проблемами многопоточности, нагреватель уже почистили,
и он снова готов к работе. Но сначала необходимо исправить допущенную ошибку.
Имеется несколько решений, каждое из которых обладает своими достоинствами
и недостатками; какое из них следует применить?
![kartinka1](https://github.com/Darya31-08/Strategy2/blob/master/img/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5-15.PNG?raw=true)

## Поздравляем!

К этому моменту все проблемы шоколадной фабрики решены. Какое бы из многопоточных решений
вы ни применили, нагреватель работает нормально, а новые сбои исключены. Поздравляем! В этой
главе мы не только разлили 500 галлонов горячего шоколада, но и рассмотрели все потенциальные
проблемы паттерна Одиночка. 
